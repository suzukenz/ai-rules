## Design Principles

Follow the essence of the Philosophy of Software Design.

- **Prioritize simplicity in all changes**: Complexity accumulates incrementally from many small dependencies and obscurities, not from single large errors. Therefore, adopt a "zero tolerance" philosophy to prevent even small additions of complexity.
- **Code must work, but great design is the primary goal**: Simply having working code is insufficient. Your main responsibility as a developer is to **facilitate future extensions** to the codebase by prioritizing the long-term structure and design quality of the system.
- **Design deep modules**: Aim for modules (classes, subsystems, services) that offer **powerful functionality behind a simple, easy-to-use interface**. A deep module hides significant internal complexity, reducing the cognitive load on its users and making future internal changes less impactful on other modules. Avoid "classitis" where classes are overly small and shallow, leading to increased system complexity.
- **Simplify interfaces for common use cases**: Design module interfaces so that **the most common usage scenarios are as simple as possible**. This often involves providing sensible default values or automatically handling tasks that are universally desirable, eliminating the need for users to explicitly configure or be aware of those details.
- **Value simple interfaces over simple implementations**: It is more important for a module's interface to be simple for its users than for its internal implementation to be simple for its developers. Module developers should absorb complexity internally to make life easier for the more numerous users of the module.
- **Strive for general-purpose modules**: Implement new modules to be "somewhat general-purpose," meaning their functionality should meet current needs but their interface should be **broad enough to support multiple, potentially unforeseen, future uses**. This often leads to simpler, deeper interfaces, better information hiding, and less code overall.
- **Strictly separate general-purpose and special-purpose code**: Ensure that specialized code (e.g., application-specific features) is **cleanly separated from general-purpose mechanisms**. Push specialization either upwards into higher-level application layers or downwards into lower-level modules like device drivers. This prevents information leakage and unnecessary interfaces.
- **Maintain distinct abstractions across layers**: Each software layer should provide a **different abstraction** from the layers directly above and below it. Avoid adjacent layers with similar abstractions, as this often indicates design problems. This principle applies to both interfaces and implementations; they should normally have different abstractions.
- **Pull complexity downwards into modules**: When unavoidable complexity arises, encapsulate it within the module that provides the related functionality, rather than exposing it to higher-level code or users. Examples include automatically handling buffering in I/O or self-adjusting configuration parameters.
- **Define errors out of existence**: Design APIs to eliminate error conditions where possible, rather than throwing exceptions. Redefine semantics so that normal behavior covers situations that might otherwise be considered errors (e.g., Unix file deletion allows continued access to a "deleted" open file, or a `substring` method auto-adjusts out-of-range indices). For unavoidable errors, consider **exception masking** (handling at a low level so higher levels are unaware) or **exception aggregation** (handling many exceptions with a single, general piece of code higher up the call stack). For truly unrecoverable errors, crashing with diagnostic information is often the simplest and best approach.
- **Employ "Design it Twice"**: For major design decisions, especially for module interfaces, **explore at least two (or more) fundamentally different approaches**. Evaluate the pros and cons of each, and either select the best or combine their strengths into a new, superior design. This iterative process enhances both the design outcome and your design skills.
- **Comments should convey non-obvious information**: Write comments to describe aspects of the code that are **not readily apparent from the code itself**. This includes reasons "why" code was implemented a certain way, higher-level objectives, design rationale, or precise details like units or invariants. Comments are essential for defining clean abstractions.
- **Design for readability, not just writability**: Prioritize the ease with which future developers can understand your code over the momentary convenience of writing it. Avoid constructs that are easy to write but obscure for readers, such as generic containers (e.g., `Pair`) without meaningful names for elements.
- **Distinguish and emphasize what matters**: Identify the most crucial aspects of your system and design around them. Things that "matter" should be emphasized through **prominence** (in interfaces, names, parameters), **repetition**, and **centrality** (at the heart of the system's structure). Conversely, minimize the impact of "unimportant" things by hiding them as much as possible.
